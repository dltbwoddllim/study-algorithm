이 문제를 heap으로 풀어야 하는 이유는 리스트를 정렬할 때 o(n*n)이 드는 selection/insertion sort에 비해 효율적이기 때문이다.
heap sort를 사용하면 o(n*logn)이다.
그 이유는 complete binary tree(높이가 logn)의 root를 min값으로 두고 부모가 자식보다 작은 값을 가지도록 해 insert와 remove method가 o(logn)이 되도록 만들기 때문이다.
두 가지 방법이 있다.
직접 heap을 구현해 푸는 방법과 java에는 PriorityQueue를 사용하는 방법

이것은 직접만든 heap으로 구현한 것이다.
효율성 테스트에서 떨어진다는 것을 알 수 있다.

정확성  테스트
테스트 1 〉	통과 (0.53ms, 52.7MB)
테스트 2 〉	통과 (0.81ms, 52.4MB)
테스트 3 〉	통과 (0.98ms, 53.8MB)
테스트 4 〉	통과 (0.86ms, 52.2MB)
테스트 5 〉	통과 (0.80ms, 52.4MB)
테스트 6 〉	통과 (11.52ms, 52.6MB)
테스트 7 〉	통과 (13.76ms, 53.2MB)
테스트 8 〉	통과 (3.72ms, 52.9MB)
테스트 9 〉	통과 (3.42ms, 52MB)
테스트 10 〉	통과 (13.24ms, 53.3MB)
테스트 11 〉	통과 (8.01ms, 53.9MB)
테스트 12 〉	통과 (19.68ms, 52.5MB)
테스트 13 〉	통과 (10.57ms, 52MB)
테스트 14 〉	통과 (1.29ms, 52MB)
테스트 15 〉	통과 (17.16ms, 53MB)
테스트 16 〉	통과 (0.78ms, 52.6MB)
효율성  테스트
테스트 1 〉	통과 (334.89ms, 68.9MB)
테스트 2 〉	통과 (855.89ms, 87.9MB)
테스트 3 〉	실패 (시간 초과)
테스트 4 〉	통과 (289.34ms, 66.2MB)
테스트 5 〉	통과 (3219.66ms, 128MB)

자바에 있는 것을 사용하면 효율성 테스트도 통과할 수 있었다.
정확성  테스트
테스트 1 〉	통과 (0.45ms, 52.6MB)
테스트 2 〉	통과 (0.44ms, 52.8MB)
테스트 3 〉	통과 (0.50ms, 52.9MB)
테스트 4 〉	통과 (0.35ms, 52.2MB)
테스트 5 〉	통과 (0.44ms, 52.1MB)
테스트 6 〉	통과 (3.42ms, 52.9MB)
테스트 7 〉	통과 (2.75ms, 52.9MB)
테스트 8 〉	통과 (0.97ms, 53MB)
테스트 9 〉	통과 (3.01ms, 52.3MB)
테스트 10 〉	통과 (5.08ms, 53.2MB)
테스트 11 〉	통과 (1.80ms, 52.5MB)
테스트 12 〉	통과 (2.94ms, 52.9MB)
테스트 13 〉	통과 (2.90ms, 53MB)
테스트 14 〉	통과 (0.54ms, 52.3MB)
테스트 15 〉	통과 (3.40ms, 52.5MB)
테스트 16 〉	통과 (0.43ms, 52.4MB)
효율성  테스트
테스트 1 〉	통과 (161.05ms, 65.8MB)
테스트 2 〉	통과 (269.13ms, 81.8MB)
테스트 3 〉	통과 (1551.71ms, 115MB)
테스트 4 〉	통과 (110.04ms, 63MB)
테스트 5 〉	통과 (1421.30ms, 117MB)

내가짠 heap과 자바에 있는 heap 비교 분석